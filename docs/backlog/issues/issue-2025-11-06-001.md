# Issue 2025-11-06-001: URL 參數與 Zustand Store 同步機制導致閃跳問題

**建立日期**: 2025-11-06  
**狀態**: ✅ resolved（由 Run run-2025-11-10-01 / Story R1.1 處理）  
**優先級**: Medium  
**相關 Run**: run-2025-11-05-01  
**相關 Story**: [Story R1.0: Zustand 階段 1 核心實作](../stories/story-r1-0-zustand-implementation.md)

---

## 問題描述

在 `admin-api-test.tsx` 頁面中，當用戶：
1. 從 index 頁點擊商店卡片進入 admin-api-test 頁面
2. 或在使用 API 功能時切換商店

會出現**商店選單閃跳**的問題，導致 UI 不穩定。

---

## 問題分析

### 根本原因

**URL 參數與 Zustand Store 的雙向同步機制**導致循環更新：

1. **URL → Zustand Store**：從 URL 讀取 handle 並更新 Zustand Store
2. **Zustand Store → URL**：從 Zustand Store 更新 URL
3. **循環觸發**：兩個 useEffect 互相觸發，導致閃跳

### 技術細節

**當前實作**：
```typescript
// useEffect 1: URL → Zustand Store
useEffect(() => {
  if (router.query.handle && router.query.handle !== selectedHandle) {
    setSelectedHandle(router.query.handle)
  }
}, [router.query.handle, selectedHandle])

// useEffect 2: Zustand Store → URL
useEffect(() => {
  if (selectedHandle && selectedHandle !== router.query.handle) {
    router.replace({ ...router.query, handle: selectedHandle })
  }
}, [selectedHandle, router.query.handle])
```

**問題**：
- 兩個 useEffect 互相依賴，形成循環
- 即使使用 `useRef` 追蹤同步狀態，仍然可能出現時序問題
- 操作 API 時，狀態更新可能觸發不必要的重新渲染

---

## 已嘗試的解決方案

### 方案 1: 使用 useRef 追蹤同步狀態
- **問題**：仍然可能出現時序問題
- **狀態**：已實作但不穩定

### 方案 2: 簡化邏輯，移除第二個 useEffect
- **問題**：URL 與 Zustand Store 可能不一致
- **狀態**：已實作但功能不完整

### 方案 3: 單一來源原則（URL 是唯一 truth source）
- **問題**：用戶手動選擇商店時需要同時更新 URL 和 Zustand Store
- **狀態**：已實作但可能仍有問題

---

## 需要架構檢視的問題

### 1. 狀態同步策略

**問題**：URL 參數和 Zustand Store 應該如何同步？

**選項 A：URL 是唯一來源（推薦）**
- Zustand Store 只從 URL 讀取
- 用戶操作時更新 URL，然後從 URL 更新 Zustand Store
- 優點：簡單、可預測
- 缺點：需要兩步更新（URL → Store）

**選項 B：Zustand Store 是唯一來源**
- URL 只從 Zustand Store 讀取
- 用戶操作時直接更新 Zustand Store，然後更新 URL
- 優點：直接、快速
- 缺點：需要處理 URL 同步

**選項 C：雙向同步（當前方案）**
- URL 和 Zustand Store 互相同步
- 優點：靈活
- 缺點：容易形成循環，需要複雜的同步邏輯

### 2. 跨頁面狀態管理

**問題**：當從 index 頁點擊商店卡片時，應該如何更新狀態？

**當前行為**：
- StoreCard 點擊時更新 Zustand Store 並導航
- admin-api-test 頁面從 URL 讀取並更新 Zustand Store
- 可能導致狀態不一致

**預期行為**：
- 點擊商店卡片時，應該更新 Zustand Store
- 導航到新頁面時，應該從 URL 讀取並同步狀態
- 不應該出現閃跳

### 3. 操作鎖定機制

**問題**：當 API 操作進行中時，狀態更新是否會影響鎖定機制？

**當前行為**：
- `useAdminAPI` Hook 使用 `lockHandle`/`unlockHandle`
- 狀態更新可能觸發重新渲染，影響鎖定狀態

**預期行為**：
- 鎖定狀態應該穩定，不受狀態更新影響
- 操作進行中時，不應該出現閃跳

---

## 建議的解決方案方向

### 方案 A：使用 Next.js Router 的事件處理（⚠️ 部分錯誤，2025-11-10 修正）

**思路**：
- ✅ **正確**：使用 `router.events` 監聽路由變化，從 URL 初始化 Zustand（只做一次）
- ❌ **錯誤**：用戶操作時「直接更新 URL，讓 Router 事件處理同步」→ 會造成循環
- ✅ **正確**：用戶操作時，先更新 Zustand，然後推送 URL（單向推送）

**⚠️ 修正（2025-11-10）**：
- ❌ **錯誤做法**：`syncFromRouter` 中更新 URL → 會造成循環
- ✅ **正確做法**：只在路由變化時從 URL 初始化一次，不更新 URL

### 方案 B：使用 Zustand 的 Middleware 或 Persist

**思路**：
- 使用 Zustand 的 URL 同步中間件
- 或使用 Persist 機制同步到 URL

**優點**：
- 利用 Zustand 生態系統
- 自動處理同步邏輯

**缺點**：
- 可能需要額外的依賴
- 學習成本較高

### 方案 C：State 分層策略（✅ 正確方案，2025-11-10 確認）

**思路**：
- ✅ **正確**：Zustand 是唯一的 Source of Truth
- ✅ **正確**：URL 只用來初始化 Zustand（可分享的上下文）
- ✅ **正確**：用戶操作時，更新 Zustand，然後推送 URL（單向推送）
- ❌ **錯誤**：「URL 是唯一來源」→ 這會造成 Dual Source of Truth

**優點**：
- 簡單、可預測
- 避免循環更新
- 符合 state-management 決策

**缺點**：
- 需要重新設計狀態管理邏輯（但這是必要的）

---

## 影響範圍

### 受影響的頁面
- `frontend/pages/admin-api-test.tsx` - 主要問題頁面
- `frontend/pages/webhook-test.tsx` - 可能有類似問題
- `frontend/components/StoreCard.tsx` - 點擊邏輯需要調整

### 受影響的功能
- 商店選擇功能
- 跨頁面狀態一致性
- API 操作鎖定機制

---

## 相關文件

- **Story 文件**：`docs/backlog/stories/story-r1-0-zustand-implementation.md`
- **狀態管理決策**：`docs/memory/decisions/state-management.md`
- **方法論**：`docs/memory/methodology.md` - Issue 開立時機

---

## 下一步行動

- ✅ 2025-11-10：Run `run-2025-11-10-01` Story R1.1 導入 Connection 狀態重構。
- ⚠️ **修正（2025-11-10）**：發現實作違反 State 分層原則，造成無限循環。
- 📌 **待修正**：按照正確的 State 分層策略重新實作：
  - Zustand 是唯一的 Source of Truth
  - URL → Zustand（只做一次初始化）
  - 用戶操作 → 更新 Zustand → 推送 URL（單向推送）
- 📌 若後續 Story 需擴充多平台 / 多 Connection 頁面，請沿用 `useConnectionRouting` 與 `connectionCache`。

---

## 臨時解決方案

**當前狀態**：已簡化邏輯，移除第二個 useEffect，只保留 URL → Zustand Store 的同步。

**建議**：在架構師檢視前，先測試當前方案是否改善問題。如果問題仍然存在，等待架構師提出更好的解決方案。

---

**預計處理時間**: Epic 4 啟動後的第一個 Run（2025-11 中旬預估）

---

**最後更新**: 2025-11-10（補充 State 分層原則，標示錯誤做法）

